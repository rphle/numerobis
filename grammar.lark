start: stmt*

?stmt: expr | variable | function
?expr: logic_or

?logic_or: logic_and | logic_or OR logic_and -> comp
?logic_and: comp | logic_and AND comp -> comp
?comp: arith ( (EQ | NE | LT | GT | LE | GE) arith )*

?arith: term | arith (ADD | SUB) term -> arith
?term: factor | term (MUL | DIV | MOD) factor -> arith
?factor: power | ADD factor -> pos | SUB factor -> neg | NOT factor -> not_op
?power: index | index POW power -> arith

?index: call | index "[" expr "]" -> index_op
?call: atom | call call_args

?atom: BOOLEAN       -> boolean
     | FLOAT         -> float
     | INTEGER       -> integer
     | STRING        -> string
     | NAME          -> name
     | "(" expr ")"
     | conditional
     | list
     | block

function: [NAME] LPAREN [function_params] RPAREN [annotation] ASSIGN expr
function_params: NAME [annotation] ("," NAME [annotation])*
call_args: "(" [expr ("," expr)*] ")"

list: "[" [expr ("," expr)*] "]"
conditional: IF expr THEN expr [ELSE expr]
variable: NAME [annotation] ASSIGN expr

block: LBRACE block_body RBRACE   -> block
block_body: (stmt ";"?)*

annotation: COLON NAME

IF: "if"
THEN: "then"
ELSE: "else"

ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/"
MOD: "%"
POW: "^"
EQ: "=="
NE: "!="
LT: "<"
GT: ">"
LE: "<="
GE: ">="
AND: "and"
OR: "or"
NOT: "not"
ASSIGN: "="
COLON: ":"

BOOLEAN: "true" | "false"
INTEGER: /\d+(_\d+)*([eE][+-]?\d+(_\d+)*)?/
FLOAT: /(\d+(_\d+)*)?\.\d+(_\d+)*([eE][+-]?\d+(_\d+)*)?/
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/

LPAREN: "("
RPAREN: ")"
LBRACK: "["
RBRACK: "]"
LBRACE: "{"
RBRACE: "}"

%import common.ESCAPED_STRING -> STRING
%import common.WS
%ignore WS
%ignore /#[^\n]*/
