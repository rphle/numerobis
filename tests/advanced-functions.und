from si import @(metre, kilogram, second, Mass, Length, Time)

# ---
curry2!(f) = !(a) = !(b) = f(a, b)
add!(x, y) = x + y
add_curried = curry2(add)
add_five = add_curried(5)
add_five(10)

# ---
curry3!(f) = !(a) = !(b) = !(c) = f(a, b, c)
sum3!(x, y, z) = x + y + z
curried = curry3(sum3)
curried(1)(2)(3)

# ---
flip!(f) = !(a, b) = f(b, a)
subtract!(x, y) = x - y
flipped = flip(subtract)
flipped(3, 10)

# ---
const!(x) = !(y) = x
always_five = const(5)
always_five(100)

# ---
compose2!(f, g) = !(x) = f(g(x))
compose3!(f, g, h) = !(x) = f(g(h(x)))
add_one!(n) = n + 1
double!(n) = n * 2
triple!(n) = n * 3
combined = compose3(add_one, double, triple)
combined(5)

# ---
pipe!(x, f) = f(x)
pipe2!(x, f, g) = g(f(x))
add_one!(n) = n + 1
double!(n) = n * 2
pipe2(5, add_one, double)

# ---
apply_list!(funcs, x) = {
    if funcs == [] then x
    else apply_list(funcs[1:], funcs[0](x))
}
inc!(n) = n + 1
dbl!(n) = n * 2
apply_list([inc, dbl, inc], 5)

# ---
map2!(f, lst1, lst2) = {
    if lst1 == [] or lst2 == [] then []
    else [f(lst1[0], lst2[0])] + map2(f, lst1[1:], lst2[1:])
}
add!(a, b) = a + b
map2(add, [1, 2, 3], [4, 5, 6])

# ---
filter!(pred, lst) = {
    if lst == [] then []
    else if pred(lst[0]) then [lst[0]] + filter(pred, lst[1:])
    else filter(pred, lst[1:])
}
is_positive!(n) = n > 0
filter(is_positive, [-1, 2, -3, 4, 5])

# ---
fold_left!(f, acc, lst) = {
    if lst == [] then acc
    else fold_left(f, f(acc, lst[0]), lst[1:])
}
add!(a, b) = a + b
fold_left(add, 0, [1, 2, 3, 4, 5])

# ---
fold_right!(f, lst, acc) = {
    if lst == [] then acc
    else f(lst[0], fold_right(f, lst[1:], acc))
}
cons!(x, xs) = [x] + xs
fold_right(cons, [1, 2, 3], [])

# ---
zip!(lst1, lst2) = {
    if lst1 == [] or lst2 == [] then []
    else [[lst1[0], lst2[0]]] + zip(lst1[1:], lst2[1:])
}
zip([1, 2, 3], [4, 5, 6])

# ---
take!(n, lst) = {
    if n <= 0 or lst == [] then []
    else [lst[0]] + take(n - 1, lst[1:])
}
take(3, [1, 2, 3, 4, 5])

# ---
drop!(n, lst) = {
    if n <= 0 or lst == [] then lst
    else drop(n - 1, lst[1:])
}
drop(2, [1, 2, 3, 4, 5])

# ---
reverse!(lst) = {
    if lst == [] then []
    else reverse(lst[1:]) + [lst[0]]
}
reverse([1, 2, 3, 4, 5])

# ---
concat!(lsts) = {
    if lsts == [] then []
    else lsts[0] + concat(lsts[1:])
}
concat([[1, 2], [3, 4], [5, 6]])

# ---
flatten!(lst) = {
    if lst == [] then []
    else lst[0] + flatten(lst[1:])
}
flatten([[1, 2], [3], [4, 5, 6]])

# ---
partition!(pred, lst) = {
    if lst == [] then [[], []]
    else {
        rest = partition(pred, lst[1:])
        if pred(lst[0]) then [[lst[0]] + rest[0], rest[1]]
        else [rest[0], [lst[0]] + rest[1]]
    }
}
is_even!(n) = n % 2 == 0
partition(is_even, [1, 2, 3, 4, 5, 6])

# ---
any!(pred, lst) = {
    if lst == [] then false
    else pred(lst[0]) or any(pred, lst[1:])
}
is_big!(n) = n > 10
any(is_big, [1, 2, 15, 4])

# ---
all!(pred, lst) = {
    if lst == [] then true
    else pred(lst[0]) and all(pred, lst[1:])
}
is_positive!(n) = n > 0
all(is_positive, [1, 2, 3, 4, 5])

# ---
find!(pred, lst) = {
    if lst == [] then []
    else if pred(lst[0]) then [lst[0]]
    else find(pred, lst[1:])
}
is_even!(n) = n % 2 == 0
find(is_even, [1, 3, 5, 6, 7])

# ---
memoized_fib = {
    cache: List = []
    !(n: Int): Int = {
        if n <= 1 then return n
        n * 2
    }
}

# ---
y_combinator!(f) = {
    inner = !(g) = f(!(x) = g(g)(x))
    inner(inner)
}

# ---
make_accumulator!(init) = {
    acc = init
    !(x) = {
        acc = acc + x
        acc
    }
}
counter = make_accumulator(0)
counter(5)

# ---
make_multiplier!(factor) = {
    !(x) = x * factor
}
times_three = make_multiplier(3)
times_three(10)

# ---
make_converter!(from_unit, to_unit, ratio) = {
    !(value) = value * ratio
}
km_to_m = make_converter(1, 1, 1000)
km_to_m(5)

# ---
partial!(f, a) = !(b, c) = f(a, b, c)
sum3!(x, y, z) = x + y + z
add_with_5 = partial(sum3, 5)
add_with_5(10, 20)

# ---
iterate!(f, n, x) = {
    if n <= 0 then x
    else iterate(f, n - 1, f(x))
}
double!(x) = x * 2
iterate(double, 5, 1)

# ---
until!(pred, f, x) = {
    if pred(x) then x
    else until(pred, f, f(x))
}
is_big!(n) = n > 100
double!(n) = n * 2
until(is_big, double, 1)

# ---
fix!(f) = !(x) = f(fix(f))(x)

# ---
trampoline!(f) = {
    result = f
    while true do {
        result = f
    }
    result
}

# E513
typed_func!(x: Int) = x * 2
typed_func("hello")

# E513
mass_func!(m: Mass) = m + 5 kilogram
mass_func(10)

# E512
two_param!(a, b) = a + b
two_param(5)

# E512
three_param!(a, b, c) = a + b + c
three_param(1, 2, 3, 4)

# E505
inconsistent_return!(x) = if x > 0 then x else "negative"
