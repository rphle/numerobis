from si import @(metre, kilogram, second, Mass, Length, Time)

# ---
curry2!(f) = !(a) = !(b) = f(a, b)
add!(x, y) = x + y
add_curried = curry2(add)
add_five = add_curried(5)
add_five(10)

# ---
curry3!(f) = !(a) = !(b) = !(c) = f(a, b, c)
sum3!(x, y, z) = x + y + z
curried = curry3(sum3)
curried(1)(2)(3)

# ---
flip!(f) = !(a, b) = f(b, a)
subtract!(x, y) = x - y
flipped = flip(subtract)
flipped(3, 10)

# ---
const!(x) = !(y) = x
always_five = const(5)
always_five(100)

# ---
compose2!(f, g) = !(x) = f(g(x))
compose3!(f, g, h) = !(x) = f(g(h(x)))
add_one!(n) = n + 1
double!(n) = n * 2
triple!(n) = n * 3
combined = compose3(add_one, double, triple)
combined(5)

# ---
pipe!(x, f) = f(x)
pipe2!(x, f, g) = g(f(x))
add_one!(n) = n + 1
double!(n) = n * 2
pipe2(5, add_one, double)

# ---
apply_list!(funcs: List[![[n:Int], Int]], x: Int): Int =
    if funcs == [] then x
    else apply_list(funcs[1:], funcs[0](x))

inc!(n) = n + 1
dbl!(n) = n * 2
apply_list([inc, dbl, inc], 5)

# ---
map2!(f:![[a: Int, b:Int], Int], lst1: List[Int], lst2: List[Int]): List[Int] =
    if lst1 == [] or lst2 == [] then []
    else [f(lst1[0], lst2[0])] + map2(f, lst1[1:], lst2[1:])

add!(a, b) = a + b
map2(add, [1, 2, 3], [4, 5, 6])

# ---
filter!(pred: ![[n:Int], Bool], lst: List[Int]): List[Int] =
    if lst == [] then []
    else if pred(lst[0]) then [lst[0]] + filter(pred, lst[1:])
    else filter(pred, lst[1:])

is_positive!(n) = n > 0
filter(is_positive, [-1, 2, -3, 4, 5])

# ---
fold_left!(f: ![[a:Int, b:Int], Int], acc: Int, lst:List[Int]): Int =
    if lst == [] then acc
    else fold_left(f, f(acc, lst[0]), lst[1:])

add!(a, b) = a + b
fold_left(add, 0, [1, 2, 3, 4, 5])

# ---
zip!(lst1: List[Int], lst2: List[Int]): List[List[Int]] =
    if lst1 == [] or lst2 == [] then []
    else [[lst1[0], lst2[0]]] + zip(lst1[1:], lst2[1:])

zip([1, 2, 3], [4, 5, 6])


# ---
take!(n: Int, lst: List[Int]): List[Int] =
    if n <= 0 or lst == [] then []
    else [lst[0]] + take(n - 1, lst[1:])

take(3, [1, 2, 3, 4, 5])


# ---
drop!(n: Int, lst: List[Int]): List[Int] =
    if n <= 0 or lst == [] then lst
    else drop(n - 1, lst[1:])

drop(2, [1, 2, 3, 4, 5])


# ---
reverse!(lst: List[Int]): List[Int] =
    if lst == [] then []
    else reverse(lst[1:]) + [lst[0]]

reverse([1, 2, 3, 4, 5])


# ---
concat!(lsts: List[List[Int]]): List[Int] =
    if lsts == [] then []
    else lsts[0] + concat(lsts[1:])

concat([[1, 2], [3, 4], [5, 6]])


# ---
flatten!(lst: List[List[Int]]): List[Int] =
    if lst == [] then []
    else lst[0] + flatten(lst[1:])

flatten([[1, 2], [3], [4, 5, 6]])

# ---
partition!(
    pred: ![[n:Int], Bool],
    lst: List[Int]
): List[List[Int]] = {
    if lst == [] then return [[], []]
    else {
        rest: List[List[Int]] = partition(pred, lst[1:])
        return if pred(lst[0])
            then [[lst[0]] + rest[0], rest[1]]
            else [rest[0], [lst[0]] + rest[1]]
    }
}

is_even!(n: Int): Bool = n % 2 == 0
partition(is_even, [1, 2, 3, 4, 5, 6])


# ---
any!(pred: ![[n:Int], Bool], lst: List[Int]): Bool =
    if lst == [] then false
    else pred(lst[0]) or any(pred, lst[1:])


is_big!(n: Int): Bool = n > 10
any(is_big, [1, 2, 15, 4])

# ---
all!(pred: ![[n:Int], Bool], lst: List[Int]): Bool =
    if lst == [] then true
    else pred(lst[0]) and all(pred, lst[1:])


is_positive!(n: Int): Bool = n > 0
all(is_positive, [1, 2, 3, 4, 5])

# ---
find!(pred: ![[n:Int], Bool], lst: List[Int]): List[Int] =
    if lst == [] then []
    else if pred(lst[0]) then [lst[0]]
    else find(pred, lst[1:])


is_even!(n: Int): Bool = n % 2 == 0
find(is_even, [1, 3, 5, 6, 7])

# ---
y_combinator!(f) = {
    inner = !(g) = f(!(x) = g(g)(x))
    inner(inner)
}

# ---
make_accumulator!(init) = {
    acc = init
    return !(x) = {
        acc = acc + x
        return acc
    }
}
counter = make_accumulator(0)
counter(5)

# ---
make_multiplier!(factor) =
    !(x) = x * factor

times_three = make_multiplier(3)
times_three(10)

# ---
make_converter!(from_unit, to_unit, ratio) =
    !(value) = value * ratio

km_to_m = make_converter(1, 1, 1000)
km_to_m(5)

# ---
partial!(f, a) = !(b, c) = f(a, b, c)
sum3!(x, y, z) = x + y + z
add_with_5 = partial(sum3, 5)
add_with_5(10, 20)

# ---
iterate!(
    f: ![[x:Int], Int], n: Int, x: Int
): Int =
    if n <= 0 then x
    else iterate(f, n - 1, f(x))


double!(x: Int): Int = x * 2
iterate(double, 5, 1)

# ---
until!(
    pred: ![[x:Int], Bool], f: ![[x:Int], Int], x: Int
): Int =
    if pred(x) then x
    else until(pred, f, f(x))


is_big!(n: Int): Bool = n > 100
double!(n: Int): Int = n * 2
until(is_big, double, 1)

# ---
fix!(f) = !(x) = f(fix(f))(x)

# ---
trampoline!(f) = {
    result = f
    while true do {
        result = f
    }
    result
}

# E513
typed_func!(x: Int) = x * 2
typed_func("hello")

# E513
mass_func!(m: Mass) = m + 5 kilogram
mass_func(10)

# E512
two_param!(a, b) = a + b
two_param(5)

# E512
three_param!(a, b, c) = a + b + c
three_param(1, 2, 3, 4)
